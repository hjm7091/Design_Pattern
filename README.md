### 1. 객체지향 모델링

![chapter1](https://user-images.githubusercontent.com/28583661/71540639-79941a00-2990-11ea-8212-47702dd3a46c.PNG)

    1) 클래스는 변화의 기본 단위, 공통의 속성과 책임을 갖는 객체들의 집합, 실제 객체를 생성하는 설계도
    2) 양방향 연관 관계는 서로의 존재를 안다는 의미, 반면에 단방향 연관 관계는 한 쪽은 알지만 다른 쪽은 모름
    3) 집합관계
        * 집약관계 -> 전체 객체와 부분 객체의 생명 주기가 다름  
        * 합성관계 -> 전체 객체가 없어지면 부분 객체도 없어짐
    4) 연관 관계 -> 클래스들이 개념상으로 서로 연결되었음을 나타냄, 실선이나 화살표로 표시,
                    보통은 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일 때 표시
       의존 관계 -> 연관 관계와 비슷하지만 차이점은 두 클래스의 관계가 한 메서드를 실행하는 동안과 같은 
                    매우 짧은 시간만 유지됨, 점선 화살표를 사용해 표시
    5) 일반화 관계(상속)는 'is a kind of 관계'지만 실체화 관계(인터페이스)는 'can do this 관계'이다.
    
* * *

### 2. 객체지향 원리

    1) 추상화는 사물들의 공통된 특징, 즉 추상적 특징을 파악해 인식의 대상으로 삼는 행위
       구체적인 개념보다는 추상적 개념에 의존해야 설계를 유연하게 변경 가능
    2) 응집도 : 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타냄(높아야 좋음)
       결합도 : 어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타냄(낮아야 좋음)
    3) 어떤 클래스의 일부 기능만 재사용하고 싶으면 위임(delegation)을 사용하자
    4) 다형성 : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
    
피터 코드의 상속 규칙

* 자식 클래스와 부모 클래스 사이는 '역할 수행' 관계가 아니어야 한다.
* 한 클래스의 인스턴스는 다른 서브 클래스의 객체로 변환할 필요가 절대 없어야 한다.
* 자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다.
* 자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 한다.
* 자식 클래스가 '역할', '트랜잭션', '디바이스' 등을 특수화해야 한다.

* * *

### 3. SOLID 원칙

단일 책임 원칙(Single Responsibility Principle, SRP)
* 객체는 단 하나의 책임만을 가져야함
* 책임 -> 해야 하는 것, 할 수 있는 것, 해야하는 것을 잘 할 수 있는 것, 변경 이유
* 시스템에 변경이 발생할 때 기존의 기능에 영향을 주는지를 평가하는 테스트를 회귀 테스트라함 
* SRP에 따른 설계를 하면 응집도는 높아지고 더불어 결합도는 낮아짐

개방-폐쇄 원칙(Open Closed Principle, OCP)
* 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야함
* 클래스를 변경하지 않고도 대상 클래스의 환경을 변경할 수 있는 설계가 되어야함

리스코프 치환 원칙(Liskov Substitution Principle, LSP)
* 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 한다는 의미
* 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야함
* LSP를 만족하는 간단한 방법은 재정의하지 않는 것이다. 이는 피터 코드의 상속 규칙에도 명시되어 있음

의존 역전 원칙(Dependency Inversion Principle, DIP)
* 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 원칙
* 인터페이스, 추상클래스 -> 변하지 않는 것, 구체 클래스 -> 변하기 쉬운 것
* DIP를 만족하려면 어떤 클래스가 도움을 받을 때 구체적인 클래스보다는 인터페이스나 추상 클래스와 의존 관계를 맺어야함

인터페이스 분리 원칙(Interface Segregation Principle, ISP)
* 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙
* SRP를 만족하더라도 ISP를 반드시 만족한다고는 할 수 없다.
  
* * *

### 4. 디자인 패턴

패턴은 비슷하거나 동일한 양식 또는 유형들이 반복되어 나타난다는 의미이며, 문제와 해결책도 동일한 유형이나 양식을 통해 쉽게 찾을 수 있음

    1) 생성 패턴 : 객체 생성에 관련된 패턴 ex) 추상 팩토리, 팩토리 메서드, 싱글턴 등
    2) 구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴 ex) 컴퍼지트, 데커레이터 등
    3) 행위 패턴 : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴 ex) 옵서버, 스테이트, 스트래티지, 템플릿 메서드, 커맨드 등 

순차 다이어그램

![순차 다이어그램](https://user-images.githubusercontent.com/28583661/71705966-7502b200-2e25-11ea-9b88-aa0e661d1bcf.PNG)

    1) 객체들의 상호작용을 나타내는 다이어그램 중 하나, 객체들 사이의 메시지 송신과 순서를 나타냄
    2) 생명선 -> 해당 객체가 존재함을 보여줌, 활성 구간 -> 실세로 객체가 연산을 실행하는 상태
    3) 비동기 메시지 -> 메시지를 송신한 후 메시지 실행이 끝나기를 기다리지 않고 다음 작업 바로 수행 가능
       동기 메시지 -> 메시지의 실행을 요청하는 객체가 메시지의 실행이 종료될 때까지 다음 작업 수행 불가능
    4) 가드 -> 메시지가 송신되는 데 만족해야 하는 조건, 응답 -> 메시지가 종료되었음을 표현
    
* * *

### 5. 스트래티지 패턴

* 스트래티지 패턴은 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴이다.
* 스트래티지 패턴은 같은 문제를 해결하는 여러 알고리즘(방식)이 클래스별로 캡슐화되어 있고 이들이 필요할 때 교체될 수 있도록 함으로써 동일한 
  문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴이다.
  
#### before (스트래티지 패턴 적용 X)

![before](https://user-images.githubusercontent.com/28583661/71764332-f3e11300-2f29-11ea-9f94-24e6d5ca8bd5.PNG)

#### after (스트래티지 패턴 적용 O)

![after](https://user-images.githubusercontent.com/28583661/71764334-f479a980-2f29-11ea-86dc-56c05909f2c6.PNG)

* * *

### 6. 싱글턴 패턴

* 싱글턴 패턴은 인스턴스가 오직 하나만 생성되는 것을 보장하고 어디에서든 인스턴스에 접근할 수 있도록 하는 디자인 패턴이다.
* 하나의 인스턴스만을 생성하는 책임이 있으며 getInstance 메서드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행함.
* 다중 스레드 애플리케이션의 경우 문제가 발생할 수 있다.
  * 해결책1 -> 정적 변수에 인스턴스를 만들어 바로 초기화하는 방법
  * 해결책2 -> 인스턴스를 만드는 메서드에 동기화(synchronized)하는 방법
  
#### 싱글턴 패턴 예제(티켓 발행 프로그램)

![ticket](https://user-images.githubusercontent.com/28583661/71818078-486fc400-30cb-11ea-9ce1-fe9211be2bed.PNG)

* TicketManager : 티켓을 발행할 책임이 있는 클래스. 싱글턴 패턴으로 구현해 유일한 시리얼 번호를 생성한다.
* Ticket : 티켓 인터페이스. 시리얼 번호를 설정하고 외부에 알려줄 책임이 있다.
* NormalTicket : 정상적인 시리얼 번호가 있는 티켓
* NullTicket : 발행할 수 있는 티켓보다 더 많은 티켓을 요구할 때 발행되는 유효하지 못한 티켓
* UserThread : TicketManager 클래스에게 티켓의 발행을 요구하는 스레드 클래스
 
* * *

### 7. 스테이트 패턴

* 스테이트 패턴은 어떤 행위를 수행할 때 상태에 행위를 수행하도록 위임한다.
* 스테이트 패턴에서는 시스템의 각 상태를 클래스로 분리해 표현하고, 각 클래스에서 수행하는 행위들을 메서드로 구현한다.
* 상태들을 외부로부터 캡슐화하기 위해 인터페이스를 만들어 시스템의 각 상태를 나타내는 클래스로 하여금 실체화하게 한다.
* 스트래티지 패턴과 유사함.
  * 차이점1 -> 스테이트 패턴에서는 행위가 자주 변경되지만 스트래티지 패턴에서는 행위가 한 번 고정되면 자주 변경되지 않는다.
  * 차이점2 -> 스테이트 패턴에서는 상태 변경을 State 요소를 구현한 클래스 자신이 수행하지만 스트래티지 패턴에서는 Client가 수행한다.
               즉, 스트래티지 패턴에서는 행위 시작과 변경이 Client 클래스에서 이루어지며 통제된다.

#### before (스테이트 패턴 적용 X)

![before](https://user-images.githubusercontent.com/28583661/71965335-ce624b00-3242-11ea-953a-de276850f934.PNG)

#### after (스테이트 패턴 적용 O)

![after](https://user-images.githubusercontent.com/28583661/71969299-ba6e1780-3249-11ea-93e1-1af7c6599562.PNG)

#### 스테이트 패턴 예제(벤딩 머신)

![vending](https://user-images.githubusercontent.com/28583661/71976976-0d9c9600-325b-11ea-8b2c-5d275646c538.PNG)

* VendingMachine : VendingMachine 클래스는 MoneyBox나 Drinking 클래스에 따라 상태가 달라지며, 상태에 따라 다른 일을 수행함.
* Drinking : 음료수에 대한 클래스. 음료수 가격과 재고 데이터를 가짐
* MoneyBox : VendingMachine 클래스가 가진 돈에 대한 클래스
* State : VendingMachine 클래스의 상태를 갖는 인터페이스
* NoMoneyState : 돈이 하나도 없는 상태
* NoEnoughMoneyState : 돈은 있으나 음료를 사기에는 부족한 상태
* EnoughMoneyState : 음료를 사기에 돈이 충분한 상태
* SoldOutState : 음료가 매진된 상태

* * *

### 8. 커맨드 패턴

* 커맨드 패턴은 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고
  재사용하고자 할 때 유용하다.
* 커맨드 패턴은 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자(Invoker) 클래스와 실제 기능을 실행하는 수신자(Receiver)
  클래스 사이의 의존성을 제거한다. 따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있도록 해준다.
  
#### before (커맨드 패턴 적용 X)

![before](https://user-images.githubusercontent.com/28583661/72197402-24620900-3464-11ea-95dc-9c5b9955f42a.PNG)

#### after (커맨드 패턴 적용 O)

![after](https://user-images.githubusercontent.com/28583661/72197556-e6fe7b00-3465-11ea-8a38-8ccdd49eba17.PNG)



* * *

### 참고 문헌

    정인상, 채흥석 (2014). 자바 객체지향 디자인 패턴. 한빛미디어.
